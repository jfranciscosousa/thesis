\chapter{Implementação}

Neste capítulo irá ser explicado todo o processo da implementação, desde as escolhas das tecnologias e às metodologias de desenvolvimento aos detalhes e pormenores de implementação de todos os componentes.

Após a definição da arquitetura, foram criados no sistema de controlo de versões remoto \textit{Github} para a implementação da plataforma:
\begin{itemize}
    \item Simuladores de dispositivos - \url{https://github.com/um-homewatch/api}
    \item \textit{Hub} - \url{https://github.com/um-homewatch/hub}
    \item \textit{Api} - \url{https://github.com/um-homewatch/stub-devices}
    \item \textit{Wrapper} da \textit{api} - \url{https://github.com/um-homewatch/js-wrapper}
    \item Aplicação cliente - \url{https://github.com/um-homewatch/app}
\end{itemize}

A ordem dos repositórios também ditam a ordem de implementação dos mesmos, seguindo a metodologia incremental e iterativa, onde os componentes foram implementados incrementalmente. O \textit{hub}, a \textit{api} e o \textit{wrapper} exibem todo o método de \textit{continuous integration}, recorrendo ao \textit{GitHub} e ao \textit{Travis}, enquanto que a \textit{api} é \textit{deployed} no \textit{Heroku}.

\section{Tecnologias}
De seguida serão apresentadas as tecnologias utilizadas para implementar a solução. Cada componente de software, o \textit{hub}, a \textit{api}, as simulações dos dispositivos e e aplicação cliente utilizam linguagens e \textit{frameworks} distintas. Aqui, iremos falar das motivações para a sua escolha.

\paragraph*{Hub}
Para o desenvolvimento deste componente recorreu-se à utilização da linguagem de programação Java, recorrendo à \textit{framework} Spark \footnote{\url{http://sparkjava.com}}.

Java foi uma escolha óbvia devido à experiência na linguagem e ao seu poder no que toca a genéricos, que permite atingir grandes níveis de reutilização de código, algo que será essencial neste caso, dado que vários dispositivos partilham o mesmo modo de comunicação por exemplo.

A \textit{framework} Spark foi escolhida devido à necessidade de expor um serviço HTTP sem ser necessário associar a um modelo arquitetural, por exemplo, algumas \textit{frameworks} são feitas para utilizar MVC. Neste caso, esta \textit{framework}, que até pode ser considerado uma biblioteca devido à sua simplicidade, tem apenas como função expor um servidor HTTP.

\paragraph*{Api}
Este componente, sendo o mais complexo de todos, necessita de uma \textit{framework} mais evoluída, portanto decidiu-se utilizar \textit{Ruby on Rails} e portanto a linguagem de programação \textit{Ruby}.

Esta \textit{framework} foi uma escolha óbvia, mais uma vez devido à experiência em trabalhos académicos passados, e também devido à simplicidade de utilização. Utilizando \textit{Ruby on Rails} podemos dedicar mais tempo a funcionalidades em vez de detalhes de implementação. Outra motivação é a existência de um bom suporte de \textit{background tasks}, que como já se falou anteriormente, era um desafio a enfrentar, para se poder implementar as tarefas automatizadas.

Utilizando esta \textit{framework}, tarefas como a camada de \textit{ORM}, filtragem de parâmetros dos pedidos HTTP, serialização de objetos para \textit{JSON} são todas tratadas pelo \textit{Rails}, podendo dar assim mais atenção a outros aspetos mais importantes da aplicação.

\paragraph*{Simulação de Dispositivos}

Para as simulações de dispositivos recorreu-se à linguagem Javascript com o \textit{runtime serverside} Node.JS, utilizando a framework \textit{express} \footnote{\url{https://expressjs.com/}}. A combinação de \textit{javascript} com o \textit{express} permite muito rapidamente desenvolver servidores web, uma vez que estes simuladores irão fornecer APIs HTTP.

Também se utilizou a biblioteca \textit{coap-router} \footnote{\url{https://github.com/MagicCube/coap-router}}, para criar os dispositivos que utilizam CoAP em vez de HTTP, como protocolo de comunicação.

\section{Detalhes}

Nesta secção irão ser detalhados alguns aspetos de uma importância acrescida, como o mecanismo de \textit{tunneling} que efetua a ligação entre vários \textit{hubs} e a \textit{api}, assim como elementos de meta-programação que permitem o crescimento do sistema em termos de dispositivos suportados, reduzindo o tempo de implementação e a manutenibilidade destes componentes. Também alguns aspetos de segurança, muito importante em contextos de IoT, vão ser explicados em mais detalhe.

\subsection{Tunneling}

Como já foi referido várias vezes durante esta dissertação, a comunicação entre o \textit{hub} e a \textit{api} iria ser feita através de um qualquer mecanismo de \textit{tunneling}, de modo a evitar tecnologias como encaminhamento de portas ou \textit{UPNP}, que têm processos de configuração complicados e algumas vulnerabilidades a nível de segurança.

Portanto, como tecnologia de \textit{tunneling} decidiu-se utilizar o \textit{ngrok} \footnote{\url{https://ngrok.com/}}, um software que permite expor serviços web locais, mesmo por de trás de \textit{firewalls} e NATs, disponibilizando este serviço num URL de acesso público. O \textit{ngrok} apesar de ser um software orientado a programadores, que desejam expor as suas aplicações web locais sem recorrer a \textit{port forwarding} para efeitos de demonstração, demonstrou ser uma das melhores soluções, pelo nesta fase do desenvolvimento.

O \textit{ngrok} irá funcionar como um processo de background, que é executado sempre que o \textit{hub} é inicializado, expondo a porta 4567 num URL gerado automaticamente.

\begin{verbatim}
    ngrok http 4567

    https://370ef754.ngrok.io
\end{verbatim}

De notar que é gerado um URL cujo acesso pode ser feito utilizando o protocolo HTTPS, que assegura a encriptação dos dados que circulam neste túnel. Este URL deve ser guardado no recurso \textit{Home} presente na \textit{api} do \textit{middleware}, no campo \textit{tunnel}, assim, o \textit{middleware} já consegue aceder à API exposta pelo \textit{hub}.

Neste preciso caso, o \textit{hub} possui antes um ficheiro de configuração com o túnel pré-definido

\begin{verbatim}
    web_addr: 0.0.0.0:4040
    region: eu
    tunnels:
      homewatch-hub:
        proto: http
        addr: 4567
\end{verbatim}

Este ficheiro define o endereço base da API do \textit{ngrok}, utilizada num mecanismo que vamos explorar já de seguida, a região do túnel, que pode ser na Europa ou nos Estados Unidos, e por fim, o túnel \textit{homewatch-hub}, expondo a porta 4567 que utiliza o protocolo HTTP.

A própria API do \textit{ngrok} é utilizada pelo \textit{hub} para fornecer o URL do túnel às aplicações clientes, para estas poderem criar o recurso \textit{Home} na \textit{api} do \textit{middleware} fornecendo o túnel do seu \textit{hub}.

\begin{verbatim}
    http://homewatch-hub:4567/tunnel

    {
        "url" : "https://a10d2075.eu.ngrok.io"
    }
\end{verbatim}

Internamente o \textit{hub} efetua um pedido à API do \textit{ngrok} e extrai o URL do túnel, devolvendo-o no típico formato JSON. As aplicações podem sempre efetuar pedidos para aquele URL, uma vez que os \textit{routers} os utilizadores possuem em casa têm na sua grande maioria um próprio servidor DNS, que resolve IPs para os \textit{hostnames} das máquinas presentes na rede que adquiriram o seu IP via DHCP, e como o \textit{hostname} de todos os \textit{hubs} é \textit{homewatch-hub}, este processo torna-se perfeitamente fazível.

Apesar de todas as mais valias e a facilidade de operação deste mecanismo, quer ao nível do utilizado quer ao nível do programador, esta abordagem também possui alguns contratempos.

O primeiro contratempo encontrado logo antes de se montar o sistema à volta desta tecnologia foi a geração automática do URL, que obriga os utilizadores a reconfigurarem os dados da sua casa, na aplicação que acede ao \textit{middleware}, sempre que o \textit{hub} reinicia (regenerando assim o URL). A solução parcial para este problema foi o desenvolvimento do mecanismo de deteção à base dos servidores de DNS locais (dos \textit{routers} do utilizador) e da API do \textit{ngrok}, que se traduz no clique de um botão na aplicação para detetar e atualizar o túnel de uma casa. Apesar de ser uma boa solução, não é perfeita, havendo o inconveniente de as tarefas automatizadas não funcionarem enquanto que o URL do túnel não for atualizado.

O outro problema consiste no limite de conexões HTTP imposto pelo \textit{ngrok} (20 por minuto), que põe em causa o funcionamento do \textit{polling} efetuado aos dispositivos através deste túnel no âmbito das tarefas automatizadas, uma vez que, cada \textit{triggered task} está sempre a monitorizar um dado dispositivo. A solução que resolveu este problema com sucesso foi a utilização de conexões persistentes HTTP \footnote{\textit{RFC HTTP Persistent Connections}: \url{https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html}}, que permite a reutilização de conexões HTTP, não causando a exaustão prematura das mesmas. Esta limitação também é evidente apenas no plano base (que é grátis), que foi utilizado para desenvolvimento.

Por fim temos o problema de segurança, uma vez que apesar do tráfego dentro do túnel utilizar HTTPS (estando encriptado portanto), qualquer pessoa pode aceder ao túnel, caso tenha o URL de acesso, e enviar comandos para o \textit{hub}. De momento resolvemos esse problema manualmente, utilizando um sistema de tokens para autenticar o acesso à API interna do \textit{hub}, oferecendo acesso exclusivo à \textit{api}. Isto é muito importante porque o objetivo é que o \textit{hub} seja de acesso privado, apenas a \textit{api} do \textit{middleware} tem permissão para aceder ao mesmo.

Num cenário ideal podia-se utilizar o \textit{ngrok link}\footnote{\textit{ngrok link}: \url{https://ngrok.com/product/ngrok-link}}, que oferece todos os benefícios deste software assim como outras funcionalidades que tornam a utilização desta tecnologia em massa muito mais acessível. Este plano resolve todos os problemas encontrados oferecendo ainda mecanismos avançados para a gestão em massa de túneis, que é exatamente o que acontece no nosso caso.
\begin{itemize}
    \item Gestão de túneis \textit{ngrok} em grande escala
    \item Reserva de endereços, basicamente garantindo a cada túnel um endereço único que nunca muda
    \item Encriptação avançada com \textit{tokens} e credenciais diferentes para cada túnel
    \item Utilização de HTTP/2 que oferece ganhos de performance consideráveis face ao HTTP
    \item IP \textit{whitelisting}, que permite garantir o acesso exclusivo apenas a certos IPs (neste caso apenas o IP da rede local do utilizador e o IP do servidor da \textit{api} eram \textit{whitelisted})
\end{itemize}

Todas estas vantagens eram oferecidas a partir de uma API poderosa exclusiva aos assinantes do \textit{ngrok link}. Esta tecnologia não foi utilizada uma vez que era orientada a negócios e a infraestruturas, não conseguindo ter acesso à mesma, no entanto, a escolha recaiu na versão base do \textit{ngrok} que permite demonstrar o funcionamento desta arquitetura e num cenário perfeito seria utilizado o \textit{ngrok link}.

\subsection{Meta-Programação}

Devido ao tamanho do projeto e à extensibilidade do mesmo, mecanismos de meta-programação tornam se um elemento muito atrativo para a redução do código escrito, conseguindo-se implementar muitas funcionalidades e mantendo todo o projeto conciso e manutenível.

Meta-programação consiste então nas muitas maneiras que um programa consegue manipular o seu próprio funcionamento durante o tempo de execução. Em muitas linguagens orientadas a objetos, como o Java por exemplo, existe um mecanismo muito usado de meta-programação, chamado de reflexões, que permite a uma aplicação obter informações sobre as classes e elementos que a compõem, por exemplo, obter uma lista com o nome dos métodos que uma classe define, ou obter todas as classes que implementam um dado interface ou que estendem uma dada classe.

Nesta secção iremos então observar como vários elementos de meta-programação permitiram simplificar longos processos de escrita de código em pequenos pedaços de código extensível recorrendo a bibliotecas de meta-programação oferecidas pelas linguagens.

\subsubsection{Hub}

Utilizando a framework web \textit{Spark}, conseguimos expor os nossos \textit{ThingServices} via uma API HTTP, como é possível ver no seguinte exemplo:

\begin{minted}{java}
ThingServiceFactory<Light> thingServiceFactory = new LightServiceFactory();
ThingController<Light> controller = new ThingController(
    thingServiceFactory,
    Light.class);

Spark.get("/devices/lights", controller::get);
Spark.put("/devices/lights", controller::put);
\end{minted}

Este exemplo faz uso da tal injeção de dependências explicada durante a fase da arquitetura, conseguindo assim ter apenas um controlador que faz a gestão de todos o tipos de dispositivos. Depois, são criadas duas rotas, uma utilizando o método GET e PUT, que se associam aos respetivos métodos no controlador. Aquela notação faz parte da API do Java 8, que permite passar métodos por referência.

Internamente, os métodos \textit{get} e \textit{put} recebem dois objetos da \textit{framework} utilizada, do tipo \textit{Request} e \textit{Response}, que têm todos os elementos do pedido HTTP proveniente do cliente assim como o objeto que representa a resposta a ser enviada. Com estes objetos é possível manipular cabeçalhos, \textit{query parameters}, entre outros.

No entanto, apesar dos mecanismos arquiteturais utilizados para simplificar o processo de adição de tipos e subtipos de dispositivos, ainda há um problema, sempre que é criado um novo tipo de dispositivo é preciso criar estas rotas manualmente, estando a aumentar a complexidade do código com \textit{boilerplate code}, código repetido sem grande significado.

Para resolver este pequeno problema decidiu-se recorrer à biblioteca de \textit{reflections} do Java, que permite inferir durante o \textit{runtime}, a lista de classes que implementa o interface \textit{Thing}. Isto é bastante útil porque podemos utilizar os métodos definidos no interface, \textit{getFactory} e \textit{getStringRepresentation}, para automaticamente criar todas as rotas necessárias para o funcionamento do \textit{hub}.

Primeiro foi criada uma classe auxiliar com um método \textit{static} para obter todas as \textit{Things} do projeto.

\begin{minted}{java}
class ClassDiscoverer {
  public static Set<Class<? extends Thing>> getThings() {
    Reflections reflections = new Reflections("homewatch.things");
    return reflections.getSubTypesOf(Thing.class);
  }
}
\end{minted}

Este método obtêm todas as classes que implementam o interface \textit{Thing} e que estejam presentes no pacote no pacote \textit{homewatch.things}, esta pesquisa por pacote permite reduzir o tempo de execução da mesma.

Depois utilizamos este método para criar as rotas correspondentes aos 5 tipos de dispositivos que se implementaram.

\begin{minted}{java}
private static void deviceControllers() {
  ClassDiscoverer.getThings().forEach(klass -> {
    try {
      Thing t = klass.newInstance();
      ThingServiceFactory thingServiceFactory = t.getFactory();
      ThingController controller = new ThingController(thingServiceFactory, klass);

      Spark.get("/devices/" + t.getStringRepresentation(), controller::get);
      Spark.put("/devices/" + t.getStringRepresentation(), controller::put);
    } catch (InstantiationException | IllegalAccessException e) {
      LoggerUtils.logException(e);
    }
  });
}
\end{minted}

Este método é chamado nas classes de \textit{setup} do projeto, que tratam do processo de inicialização e configuração do pequeno servidor, e essencialmente percorre a lista de classes retornada pelo método \textit{getThings}, utilizando os dois métodos utilitários, \textit{getFactory} e \textit{getStringRepresentation} para criar as rotas de acesso aos serviços dinamicamente. Desta maneira, desde que os interfaces dos dispositivos retornem a \textit{factory} respetiva e afixando a descrição do dispositivo à rota de acesso.

Exemplificando o funcionamento deste mecanismo, se tivermos um dispositivo \textit{Light} onde o método \textit{getFactory} retorna um \textit{LightServiceFactory} e onde o método \textit{getStringRepresentation} retorna \textit{''lights''}, irá ser criado um \textit{controller} utilizando um \textit{LightServiceFactory}, e depois serão criadas duas rotas, \textit{''/devices/lights''} com os métodos GET e PUT.

Assim, conseguimos automaticamente instanciar todos os \textit{controllers} sem ter que repetir pedaços de código idênticos, que iriam acabar por se tornar muito numerosos com o crescimento de tipos de dispositivos.

\subsubsection{Api}